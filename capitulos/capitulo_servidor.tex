\chapter{Servidor}

% Introdução ao programa servidor
%=====================================
O servidor é o software embarcado no HPS do Soc. Ele é o responsável por gerenciar a comunicação entre a interface de rede por onde recebe os dados provenientes do pacote ROS (cliente) e o FPGA\@. A primeira etapa a ser concluída no desenvolvimento do servidor é compilação de uma versão linux para processadores ARM que será instalada no kit de desenvolvimento. O fluxo de boot do linux na placa é resumido na Figura~\ref{fig:linux}. 

% explicar processo de boot
%=====================================
\section{Processo de BOOT}
O primeiro elemento de software é o \textit{Boot ROM} que está gravado de fábrica internamente no dispositivo. Os arquivos de \textit{PreLoader},\textit{ U-boot} e do sistemas de aquivos do linux são salvos em um cartão de memória micro SD\@. O \textit{Secondary Program Loader - SPL}, conhecido como \textit{PreLoader}, é executado a partir da Boot ROM\@. Ele é responsável por configurar o sistema para que o \textit{bootloader} (U-boot) possa ser executado. A Intel fornece uma ferramenta chamada BSP editor que, a partir de arquivos que descrevem o hardware, podem gerar o PreLoader para o projeto específico~\cite{SocLinux}.  

\begin{figure}[ht]
	\caption{Boot linux embarcado}
	\begin{center}
		\includegraphics[scale=0.7]{imagens/embeddedLinux.png}\\
		{\small \textbf{Fonte:}\cite{SocLinux}}
    \end{center}\label{fig:linux}
\end{figure}

A etapa seguinte ao \textit{PreLoader} é o \textit{bootloader}. Nessa fase do boot todas as questões de baixo nível do SoC, como por exemplo, os clocks, pinos e SDRAM, já foram inicializados e estão prontos. O objetivo do bootloader, é obter essas informações do sistema e fazer com que ele funcione até o ponto onde o linux possa ser iniciado. Outra função importante do U-boot em um SoC Intel é programar o FPGA~\cite{SocLinux}.

% Explicar a distribuição usada
%=====================================
\section{Distribuição Linux rsyocto}
Com todos os arquivos necessários para o boot do sistema já gerados a partir das ferramentas de desenvolvimento da Intel, poderemos escolher nosso sistema operacional. O sistema escolhido foi uma distribuição linux desenvolvida exclusivamente para SoCs da Intel com fpga integrado, como pode ser observado na descrição da distribuição disponível em~\cite{rsyocto}:

\begin{citacao}
	``\textbf{rsyocto} is an open source Embedded Linux Distribution designed with the Yocto Project and with a custom build flow to be optimized for Intel SoC-FPGAs (Intel Cyclone V and Intel Arria 10 SX SoC-FPGA with an ARM Cortex-A9) to achieve the best customization for the strong requirements of modern embedded SoC-FPGA applications.''
\end{citacao} 

O rsyocto faz uso do Kernel Linux~\textbf{linux-socfpga 5.11}~\cite{linuxsocfpga} e possui um conjunto de ferramentas necessárias para ajudar a simplificar o uso e desenvolvimento de aplicações desenvolvidas para os SoCs com FPGA integrado da Intel. Além destas ferramentas o rsyocto dispõe de drivers para todos os periféricos de comunicação integrados SoC, como por exemplo, a interfaces I2C e CAN, e para todas as interfaces entres o HPS e o FPGA\@. O rsyocto oferece um conjunto de simples aplicações que podem ser executadas em linha de comando, que possibilitam executar novas configurações no FPGA, usando o FPGA Manager, até mesmo ler e escrever a interface ARM AXI-Bridge que permite interagir com o FPGA\@. 

Essas aplicações simplificam a comunicação com o FPGA a partir de simples comandos que podem ser executados a partir do terminal, através de todas as interfaces disponíveis, estes comandos são:~\textbf{lwhps2fpga}, que permite ações de leitura e escrita no barramento Lightweight HPS-to-FPGA-Bridge, o~\textbf{hps2fpga} para leitura e escrita no barramento HPS-to-FPGA-Bridge, o~\textbf{hps2sdram}, que proporciona acesso à interface da SDRAM e os~\textbf{gpi} e~\textbf{gpo} para acesso aos sinais de uso geral. Na Figura~\ref{fig:rsyocto} podemos ter uma visão geral de todas as ferramentas disponíveis na distribuição linux~\textit{rsyocto}.


\begin{figure}[ht]
	\caption{Overview do rsyocto}
	\begin{center}
		\includegraphics[scale=0.45]{imagens/rsYoctoLayers.jpg}\\
		{\small \textbf{Fonte:}\cite{rsyocto}}
    \end{center}\label{fig:rsyocto}
\end{figure}

A seguir são listadas algumas características da distribuição linux rsyocto que fazem dela uma excelente escolha para ser utilizada neste trabalho:
\begin{itemize}
	\item Embedded Linux specially developed for Intel SoC-FPGAs
	\item Linux Kernel 5.11 (Source)
	\item Full usage of the Dual-Core ARM (ARMv7-A) Cortex-A9 with
	\item FPGA Fabric configuration during the boot and with a single Linux command
	\item All Bridge Interfaces between the HPS and FPGA are enabled and ready for use!
	\item Tools to interact with the FPGA Fabric via the ARM AXI HPS-to-FPGA bridges
	\item HPS Hard IP components (I²C-,SPI-, CAN-BUS or UART) are routed to FPGA 
	\item USB Host support with test tools (e.g. lsusb)
	\item Full Linux Network stack with dynamic and static iPv4 is supported
	\item OpenSSH-Server starts automatically during boot
	\item gcccompiler 9.3.0; glibc and glib-2.0(The GNU C Library) cmake 3.16.5
	\item Python 3.8 Python3-dev and Python-dev
	\item git 2.31, wget 1.20.3, curl 7.69.1
	\item opkg package manager enables to add packages from different Linux Distributions.
	\item Changing the running FPGA-Configuration of the FPGA-Fabric
	\end{itemize}

% Explicar o códgo do servidor
%=====================================
\section{Interface socket server}
Com o linux já devidamente configurado, ele já pode ser inicializado no processador do SoC, assim podemos iniciar o desenvolvimento do servidor. No primeiro momento devemos realizar o download do código fonte da biblioteca de comunicação, a libinterfacesocket, que já foi detalhada anteriormente, o código fonte pode ser baixado em~\cite{interface-socket-server}. Com os arquivos já no sistema de diretórios do SoC devemos realizar a compilação e a instalação da libinterfacesocket, só assim o servidor terá acesso a suas funcionalidades. 

O acesso do servidor ao FPGA é feito através de mapeamento de endereços do linux, os SoCs Intel possuem uma arquitetura de memória mapeada. Desta forma, além da biblioteca desenvolvida durante a pesquisa, um outro arquivo cabeçalho é necessário para facilitar o acesso aos endereços de memória do HPS\@. Quando uma instância do processador ARM é incluída no projeto do QSys Designer, é gerado um arquivo.sopcinfo no momento em que o projeto é compilado. Podemos usar esse arquivo como entrada da ferramenta \textit{sopc-create-header-files} presente no SoC EDS para gerar um novo arquivo com extensão \textit{.h}, que lista os endereços base de todos os módulos (IP) incluídos no FPGA\@. Portanto, o arquivo cabeçalho gerado disponibiliza o \textit{offset} do endereço em que cada periférico está localizado para cada uma das FPGA-bridges disponíveis. Deste modo o servidor pode enviar ou receber dados ao periférico conhecendo o endereço da FPGA-bridge em que este periférico está conectado e o seu nome, sem a necessidade de se conhecer exatamente o seu endereço.

O Servidor mantém porta aberta para estabelecer uma conexão com o cliente e assim que a conexão é estabelecida, o cliente já pode começar a enviar os dados. Ao receber os dados do cliente, o servidor envia-os ao FPGA que os processa e os devolve ao servidor para que ele possa reenviar os dados já processados ao cliente. Um fluxograma simplificado desse processo pode ser visualizado na Figura \ref{fig:fluxoServidor}.

\begin{figure}[ht]
	\caption{Fluxograma simplificado do servidor}
	\begin{center}
		\includegraphics[scale=0.47]{imagens/fluxogramaServidor.png}\\
		{\small \textbf{Fonte:}Elaborado pelo autor}
    \end{center}\label{fig:fluxoServidor}
\end{figure} 
